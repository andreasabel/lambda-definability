<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>PeirceNotDefinable</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">-- Simply-typed lambda definability and normalization by evaluation</a>
<a id="69" class="Comment">-- formalized in Agda</a>
<a id="91" class="Comment">--</a>
<a id="94" class="Comment">-- Author: Andreas Abel, May/June 2018</a>

<a id="134" class="Comment">-- 4. Using Kripke predicates to refute STLC-definability of an inhabitant of Peirce&#39;s formula.</a>

<a id="231" class="Comment">-- There is no λ-definable function in the Peirce type ((A → B) → A) → A</a>

<a id="305" class="Symbol">{-#</a> <a id="309" class="Keyword">OPTIONS</a> <a id="317" class="Pragma">--postfix-projections</a> <a id="339" class="Symbol">#-}</a>
<a id="343" class="Symbol">{-#</a> <a id="347" class="Keyword">OPTIONS</a> <a id="355" class="Pragma">--rewriting</a> <a id="367" class="Symbol">#-}</a>

<a id="372" class="Keyword">open</a> <a id="377" class="Keyword">import</a> <a id="384" href="Library.html" class="Module">Library</a>
<a id="392" class="Keyword">import</a> <a id="399" href="SimpleTypes.html" class="Module">SimpleTypes</a>
<a id="411" class="Keyword">import</a> <a id="418" href="STLCDefinable.html" class="Module">STLCDefinable</a>

<a id="433" class="Keyword">module</a> <a id="440" href="PeirceNotDefinable.html" class="Module">PeirceNotDefinable</a> <a id="459" class="Keyword">where</a>

<a id="466" class="Comment">-- We consider the Peirce formula over two &quot;empty&quot; base types:</a>

<a id="530" class="Keyword">data</a> <a id="Base"></a><a id="535" href="PeirceNotDefinable.html#535" class="Datatype">Base</a> <a id="540" class="Symbol">:</a> <a id="542" class="PrimitiveType">Set</a> <a id="546" class="Keyword">where</a>
  <a id="Base.a"></a><a id="554" href="PeirceNotDefinable.html#554" class="InductiveConstructor">a</a> <a id="Base.b"></a><a id="556" href="PeirceNotDefinable.html#556" class="InductiveConstructor">b</a> <a id="558" class="Symbol">:</a> <a id="560" href="PeirceNotDefinable.html#535" class="Datatype">Base</a>

<a id="566" class="Comment">-- In the set-interpretation, the types are actually not empty.</a>
<a id="630" class="Comment">-- If they were, we would not be able to get the necessary witnesses.</a>

<a id="B⦅_⦆"></a><a id="701" href="PeirceNotDefinable.html#701" class="Function Operator">B⦅_⦆</a> <a id="706" class="Symbol">:</a> <a id="708" href="PeirceNotDefinable.html#535" class="Datatype">Base</a> <a id="713" class="Symbol">→</a> <a id="715" class="PrimitiveType">Set</a>
<a id="719" href="PeirceNotDefinable.html#701" class="Function Operator">B⦅</a> <a id="722" class="Symbol">_</a> <a id="724" href="PeirceNotDefinable.html#701" class="Function Operator">⦆</a> <a id="726" class="Symbol">=</a> <a id="728" href="Agda.Builtin.Unit.html#137" class="Record">⊤</a>

<a id="731" class="Comment">-- We consider λ-calculus with no constants</a>

<a id="776" class="Keyword">open</a> <a id="781" href="SimpleTypes.html" class="Module">SimpleTypes</a>   <a id="795" href="PeirceNotDefinable.html#535" class="Datatype">Base</a> <a id="800" href="PeirceNotDefinable.html#701" class="Function Operator">B⦅_⦆</a>
<a id="805" class="Keyword">open</a> <a id="810" href="STLCDefinable.html" class="Module">STLCDefinable</a> <a id="824" href="PeirceNotDefinable.html#535" class="Datatype">Base</a> <a id="829" href="PeirceNotDefinable.html#701" class="Function Operator">B⦅_⦆</a> <a id="834" href="Data.Empty.html#279" class="Datatype">⊥</a> <a id="836" href="Data.Empty.html#294" class="Function">⊥-elim</a> <a id="843" class="Symbol">(λ())</a>

<a id="A"></a><a id="850" href="PeirceNotDefinable.html#850" class="Function">A</a> <a id="852" class="Symbol">=</a> <a id="854" href="SimpleTypes.html#570" class="InductiveConstructor">base</a> <a id="859" href="PeirceNotDefinable.html#554" class="InductiveConstructor">a</a>
<a id="B"></a><a id="861" href="PeirceNotDefinable.html#861" class="Function">B</a> <a id="863" class="Symbol">=</a> <a id="865" href="SimpleTypes.html#570" class="InductiveConstructor">base</a> <a id="870" href="PeirceNotDefinable.html#556" class="InductiveConstructor">b</a>

<a id="873" class="Comment">-- A counter model to the Peirce type:</a>
<a id="912" class="Comment">-- We interpret A as being-a-projection</a>
<a id="952" class="Comment">-- and B as the empty predicate.</a>

<a id="IsProjection"></a><a id="986" href="PeirceNotDefinable.html#986" class="Function">IsProjection</a> <a id="999" class="Symbol">:</a> <a id="1001" class="Symbol">∀</a> <a id="1003" href="PeirceNotDefinable.html#1003" class="Bound">Γ</a> <a id="1005" href="PeirceNotDefinable.html#1005" class="Bound">T</a> <a id="1007" class="Symbol">(</a><a id="1008" href="PeirceNotDefinable.html#1008" class="Bound">f</a> <a id="1010" class="Symbol">:</a> <a id="1012" href="SimpleTypes.html#1490" class="Function">Fun</a> <a id="1016" href="PeirceNotDefinable.html#1003" class="Bound">Γ</a> <a id="1018" href="PeirceNotDefinable.html#1005" class="Bound">T</a><a id="1019" class="Symbol">)</a> <a id="1021" class="Symbol">→</a> <a id="1023" class="PrimitiveType">Set</a>
<a id="1027" href="PeirceNotDefinable.html#986" class="Function">IsProjection</a> <a id="1040" href="PeirceNotDefinable.html#1040" class="Bound">Γ</a> <a id="1042" href="PeirceNotDefinable.html#1042" class="Bound">T</a> <a id="1044" href="PeirceNotDefinable.html#1044" class="Bound">f</a> <a id="1046" class="Symbol">=</a> <a id="1048" href="Data.Product.html#1364" class="Function">∃</a> <a id="1050" class="Symbol">λ</a> <a id="1052" class="Symbol">(</a><a id="1053" href="PeirceNotDefinable.html#1053" class="Bound">x</a> <a id="1055" class="Symbol">:</a> <a id="1057" href="STLCDefinable.html#2356" class="Datatype">Var</a> <a id="1061" href="PeirceNotDefinable.html#1042" class="Bound">T</a> <a id="1063" href="PeirceNotDefinable.html#1040" class="Bound">Γ</a><a id="1064" class="Symbol">)</a> <a id="1066" class="Symbol">→</a> <a id="1068" href="PeirceNotDefinable.html#1044" class="Bound">f</a> <a id="1070" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1072" href="STLCDefinable.html#3466" class="Function Operator">V⦅</a> <a id="1075" href="PeirceNotDefinable.html#1053" class="Bound">x</a> <a id="1077" href="STLCDefinable.html#3466" class="Function Operator">⦆</a>

<a id="NP-Base"></a><a id="1080" href="PeirceNotDefinable.html#1080" class="Function">NP-Base</a> <a id="1088" class="Symbol">:</a> <a id="1090" href="STLCDefinable.html#682" class="Record">STLC-KLP-Base</a>
<a id="1104" href="PeirceNotDefinable.html#1080" class="Function">NP-Base</a> <a id="1112" class="Symbol">.</a><a id="1113" href="STLCDefinable.html#721" class="Field Operator">STLC-KLP-Base.B⟦_⟧</a> <a id="1132" href="PeirceNotDefinable.html#554" class="InductiveConstructor">a</a> <a id="1134" href="PeirceNotDefinable.html#1134" class="Bound">Γ</a> <a id="1136" href="PeirceNotDefinable.html#1136" class="Bound">f</a> <a id="1138" class="Symbol">=</a> <a id="1140" href="PeirceNotDefinable.html#986" class="Function">IsProjection</a> <a id="1153" href="PeirceNotDefinable.html#1134" class="Bound">Γ</a> <a id="1155" href="PeirceNotDefinable.html#850" class="Function">A</a> <a id="1157" href="PeirceNotDefinable.html#1136" class="Bound">f</a>
<a id="1159" href="PeirceNotDefinable.html#1080" class="Function">NP-Base</a> <a id="1167" class="Symbol">.</a><a id="1168" href="STLCDefinable.html#721" class="Field Operator">STLC-KLP-Base.B⟦_⟧</a> <a id="1187" href="PeirceNotDefinable.html#556" class="InductiveConstructor">b</a> <a id="1189" href="PeirceNotDefinable.html#1189" class="Bound">Γ</a> <a id="1191" href="PeirceNotDefinable.html#1191" class="Bound">f</a> <a id="1193" class="Symbol">=</a> <a id="1195" href="Data.Empty.html#279" class="Datatype">⊥</a>  <a id="1198" class="Comment">-- b is always empty</a>
<a id="1219" href="PeirceNotDefinable.html#1080" class="Function">NP-Base</a> <a id="1227" class="Symbol">.</a><a id="1228" href="STLCDefinable.html#759" class="Field">STLC-KLP-Base.monB</a> <a id="1247" href="PeirceNotDefinable.html#554" class="InductiveConstructor">a</a> <a id="1249" href="PeirceNotDefinable.html#1249" class="Bound">τ</a> <a id="1251" class="Symbol">(</a><a id="1252" href="PeirceNotDefinable.html#1252" class="Bound">x</a> <a id="1254" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1256" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="1260" class="Symbol">)</a> <a id="1262" class="Symbol">=</a> <a id="1264" href="PeirceNotDefinable.html#1252" class="Bound">x</a> <a id="1266" href="STLCDefinable.html#2918" class="Function Operator">w[</a> <a id="1269" href="PeirceNotDefinable.html#1249" class="Bound">τ</a> <a id="1271" href="STLCDefinable.html#2918" class="Function Operator">]ᵛ</a> <a id="1274" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1276" href="Relation.Binary.PropositionalEquality.Core.html#939" class="Function">sym</a> <a id="1280" class="Symbol">(</a><a id="1281" href="STLCDefinable.html#3892" class="Function">wk-evalv</a> <a id="1290" href="PeirceNotDefinable.html#1252" class="Bound">x</a> <a id="1292" href="PeirceNotDefinable.html#1249" class="Bound">τ</a><a id="1293" class="Symbol">)</a>
<a id="1295" href="PeirceNotDefinable.html#1080" class="Function">NP-Base</a> <a id="1303" class="Symbol">.</a><a id="1304" href="STLCDefinable.html#759" class="Field">STLC-KLP-Base.monB</a> <a id="1323" href="PeirceNotDefinable.html#556" class="InductiveConstructor">b</a> <a id="1325" href="PeirceNotDefinable.html#1325" class="Bound">τ</a> <a id="1327" class="Symbol">()</a>

<a id="NP"></a><a id="1331" href="PeirceNotDefinable.html#1331" class="Function">NP</a> <a id="1334" class="Symbol">:</a> <a id="1336" href="STLCDefinable.html#1657" class="Record">STLC-KLP</a>
<a id="1345" href="PeirceNotDefinable.html#1331" class="Function">NP</a> <a id="1348" class="Symbol">.</a><a id="1349" href="STLCDefinable.html#1691" class="Field">STLCDefinable.STLC-KLP.klp-base</a> <a id="1381" class="Symbol">=</a> <a id="1383" href="PeirceNotDefinable.html#1080" class="Function">NP-Base</a>
<a id="1391" href="PeirceNotDefinable.html#1331" class="Function">NP</a> <a id="1394" class="Symbol">.</a><a id="1395" href="STLCDefinable.html#1801" class="Field">STLCDefinable.STLC-KLP.satC</a> <a id="1423" class="Symbol">()</a>

<a id="Peirce"></a><a id="1427" href="PeirceNotDefinable.html#1427" class="Function">Peirce</a> <a id="1434" class="Symbol">=</a> <a id="1436" class="Symbol">((</a><a id="1438" href="PeirceNotDefinable.html#850" class="Function">A</a> <a id="1440" href="SimpleTypes.html#595" class="InductiveConstructor Operator">⇒</a> <a id="1442" href="PeirceNotDefinable.html#861" class="Function">B</a><a id="1443" class="Symbol">)</a> <a id="1445" href="SimpleTypes.html#595" class="InductiveConstructor Operator">⇒</a> <a id="1447" href="PeirceNotDefinable.html#850" class="Function">A</a><a id="1448" class="Symbol">)</a> <a id="1450" href="SimpleTypes.html#595" class="InductiveConstructor Operator">⇒</a> <a id="1452" href="PeirceNotDefinable.html#850" class="Function">A</a>

<a id="1455" class="Comment">-- Lemma: Cannot project anything from the empty context.</a>

<a id="no-proj-from-ε"></a><a id="1514" href="PeirceNotDefinable.html#1514" class="Function">no-proj-from-ε</a> <a id="1529" class="Symbol">:</a> <a id="1531" class="Symbol">∀</a> <a id="1533" href="PeirceNotDefinable.html#1533" class="Bound">T</a> <a id="1535" class="Symbol">{</a><a id="1536" href="PeirceNotDefinable.html#1536" class="Bound">f</a> <a id="1538" class="Symbol">:</a> <a id="1540" href="SimpleTypes.html#1490" class="Function">Fun</a> <a id="1544" href="SimpleTypes.html#694" class="InductiveConstructor">ε</a> <a id="1546" href="PeirceNotDefinable.html#1533" class="Bound">T</a><a id="1547" class="Symbol">}</a> <a id="1549" class="Symbol">(</a><a id="1550" href="PeirceNotDefinable.html#1550" class="Bound">p</a> <a id="1552" class="Symbol">:</a> <a id="1554" href="PeirceNotDefinable.html#986" class="Function">IsProjection</a> <a id="1567" href="SimpleTypes.html#694" class="InductiveConstructor">ε</a> <a id="1569" href="PeirceNotDefinable.html#1533" class="Bound">T</a> <a id="1571" href="PeirceNotDefinable.html#1536" class="Bound">f</a><a id="1572" class="Symbol">)</a> <a id="1574" class="Symbol">→</a> <a id="1576" href="Data.Empty.html#279" class="Datatype">⊥</a>
<a id="1578" href="PeirceNotDefinable.html#1514" class="Function">no-proj-from-ε</a> <a id="1593" class="Symbol">_</a> <a id="1595" class="Symbol">(()</a> <a id="1599" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1601" class="Symbol">_)</a>

<a id="1605" class="Comment">-- Theorem: the Peirce type is not inhabited in STLC.</a>

<a id="1660" class="Comment">-- The argument runs just like the Kripke countermodel for Peirce in IPL.</a>

<a id="1735" class="Comment">-- We can drop the functions like f since we interpeted A and B as ⊤</a>
<a id="1804" class="Comment">-- in the set-theoretic interpretation.</a>

<a id="1845" class="Comment">-- Proof: Suppose ⟦ Pierce ⟧ ε and derive a contradiction.</a>
<a id="1904" class="Comment">-- Since ⟦ A ⟧ ε is false (&quot;no-proj-from-ε A&quot;), it is sufficient to show ⟦ (A → B) → A ⟧ ε.</a>
<a id="1996" class="Comment">-- Assume τ : Δ ≤ ε and ⟦ A → B ⟧ Δ.  We show ⟦ A ⟧ Δ by absurdity of ⟦ A → B ⟧ Δ (&quot;lemma&quot;).</a>
<a id="2089" class="Comment">-- To this end, note that ⟦ A ⟧ (Δ.A) holds while ⟦ B ⟧ (Δ.A) is false (irrespective of Δ).</a>

<a id="thm"></a><a id="2182" href="PeirceNotDefinable.html#2182" class="Function">thm</a> <a id="2186" class="Symbol">:</a> <a id="2188" class="Symbol">∀</a> <a id="2190" href="PeirceNotDefinable.html#2190" class="Bound">f</a> <a id="2192" class="Symbol">→</a> <a id="2194" href="STLCDefinable.html#2020" class="Function">STLC-definable</a> <a id="2209" href="SimpleTypes.html#694" class="InductiveConstructor">ε</a> <a id="2211" href="PeirceNotDefinable.html#1427" class="Function">Peirce</a> <a id="2218" href="PeirceNotDefinable.html#2190" class="Bound">f</a> <a id="2220" class="Symbol">→</a> <a id="2222" href="Data.Empty.html#279" class="Datatype">⊥</a>
<a id="2224" href="PeirceNotDefinable.html#2182" class="Function">thm</a> <a id="2228" href="PeirceNotDefinable.html#2228" class="Bound">f</a> <a id="2230" href="PeirceNotDefinable.html#2230" class="Bound">def</a> <a id="2234" class="Symbol">=</a> <a id="2236" href="PeirceNotDefinable.html#1514" class="Function">no-proj-from-ε</a> <a id="2251" href="PeirceNotDefinable.html#850" class="Function">A</a> <a id="2253" class="Symbol">(</a><a id="2254" href="PeirceNotDefinable.html#2230" class="Bound">def</a> <a id="2258" href="PeirceNotDefinable.html#1331" class="Function">NP</a> <a id="2261" href="SimpleTypes.html#812" class="InductiveConstructor">id≤</a> <a id="2265" class="Symbol">(λ</a> <a id="2268" href="PeirceNotDefinable.html#2268" class="Bound">τ</a> <a id="2270" href="PeirceNotDefinable.html#2270" class="Bound">⟦d⟧</a> <a id="2274" class="Symbol">→</a> <a id="2276" href="PeirceNotDefinable.html#2360" class="Function">lemma</a> <a id="2282" href="PeirceNotDefinable.html#2270" class="Bound">⟦d⟧</a><a id="2285" class="Symbol">))</a>
  <a id="2290" class="Keyword">where</a>
  <a id="2298" class="Keyword">open</a> <a id="2303" href="STLCDefinable.html#1657" class="Module">STLC-KLP</a> <a id="2312" href="PeirceNotDefinable.html#1331" class="Function">NP</a>

  <a id="2318" class="Comment">-- Lemma: T⟦ A ⇒ B ⟧ Δ is always false.</a>
  <a id="2360" href="PeirceNotDefinable.html#2360" class="Function">lemma</a> <a id="2366" class="Symbol">:</a> <a id="2368" class="Symbol">∀</a> <a id="2370" class="Symbol">{</a><a id="2371" href="PeirceNotDefinable.html#2371" class="Bound">Δ</a> <a id="2373" href="PeirceNotDefinable.html#2373" class="Bound">d</a><a id="2374" class="Symbol">}</a> <a id="2376" class="Symbol">→</a> <a id="2378" href="STLCDefinable.html#1024" class="Function Operator">T⟦</a> <a id="2381" href="PeirceNotDefinable.html#850" class="Function">A</a> <a id="2383" href="SimpleTypes.html#595" class="InductiveConstructor Operator">⇒</a> <a id="2385" href="PeirceNotDefinable.html#861" class="Function">B</a> <a id="2387" href="STLCDefinable.html#1024" class="Function Operator">⟧</a> <a id="2389" href="PeirceNotDefinable.html#2371" class="Bound">Δ</a> <a id="2391" href="PeirceNotDefinable.html#2373" class="Bound">d</a> <a id="2393" class="Symbol">→</a> <a id="2395" class="Symbol">∀{</a><a id="2397" href="PeirceNotDefinable.html#2397" class="Bound">X</a> <a id="2399" class="Symbol">:</a> <a id="2401" class="PrimitiveType">Set</a><a id="2404" class="Symbol">}</a> <a id="2406" class="Symbol">→</a> <a id="2408" href="PeirceNotDefinable.html#2397" class="Bound">X</a>
  <a id="2412" href="PeirceNotDefinable.html#2360" class="Function">lemma</a> <a id="2418" href="PeirceNotDefinable.html#2418" class="Bound">⟦d⟧</a> <a id="2422" class="Symbol">=</a> <a id="2424" href="Function.html#3662" class="Function Operator">case</a> <a id="2429" href="PeirceNotDefinable.html#2418" class="Bound">⟦d⟧</a> <a id="2433" class="Symbol">(</a><a id="2434" href="SimpleTypes.html#834" class="InductiveConstructor">weak</a> <a id="2439" href="SimpleTypes.html#812" class="InductiveConstructor">id≤</a><a id="2442" class="Symbol">)</a> <a id="2444" class="Symbol">(</a><a id="2445" href="STLCDefinable.html#2395" class="InductiveConstructor">vz</a> <a id="2448" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="2450" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="2454" class="Symbol">)</a> <a id="2456" href="Function.html#3662" class="Function Operator">of</a> <a id="2459" class="Symbol">λ()</a>

<a id="2464" class="Comment">-- Q.E.D.</a>
</pre></body></html>