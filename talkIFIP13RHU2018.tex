\nonstopmode
\documentclass[t,fleqn,usenames,dvipsnames]{beamer}
%\documentclass{article}\usepackage{beamerarticle}

\makeatletter
%\def\leqn{\tagsleft@true}
%\def\reqn{\tagsleft@false}
\def\fleq{\@fleqntrue\let\mathindent\@mathmargin \@mathmargin=\leftmargini}
\def\cneq{\@fleqnfalse}
\g@addto@macro{\endsubequations}{\addtocounter{equation}{-1}}
\makeatother

\mode<presentation>
{
  % \usetheme{AnnArbor}
  \useinnertheme[shadow=true]{rounded}
  \useoutertheme{infolines}
  %\setbeamercolor*{title in head/foot}{parent=palette secondary}
  %\useoutertheme{shadow}
  \usecolortheme{wolverine}

  \setbeamerfont{block title}{size={}}
  \setbeamercolor{titlelike}{parent=structure,bg=yellow!85!orange}

  % My modification: centered title with white background
  \setbeamercolor{frametitle}{bg=white}
  \setbeamertemplate{frametitle}{
    %\begin{center}
      \Large\insertframetitle
      \vspace{1ex}
      %\hline
      \par
    %\end{center}
  }
  % %% Does not work
  % \setbeamercolor{frametitlecentered}{bg=white}
  % \setbeamertemplate{frametitlecentered}{
  %   \begin{center}
  %     \Large\insertframetitle
  %     \par
  %   \end{center}
  % }
  % plus red emphasis
  \setbeamercolor{alerted text}{fg=red!70!black}

  % More space between items
  %\defbeamertemplate*{itemize/enumerate body begin}{default}{\itemsep1ex}


  \setbeamercolor{math text}{parent=titlelike}
%  \setbeamercolor{math text displayed}{parent=palette primary}

  % Fix background of theorems/proof
  \setbeamercolor{block body}{parent=palette primary}%{bg=yellow!85!orange}
  \setbeamercolor{block title}{parent=palette secondary}%{bg=orange}



  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)

} % end mode presentation

%\usepackage{tcolorbox}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
%\usepackage{times}  % DYSFUNCTIONAL! looks awful when mixing mathtt and ordinary math.
\usepackage{ifthen}
%\usepackage[T1]{fontenc} %no effect
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.
\usepackage{bbm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{alltt}
\usepackage[normalem]{ulem} % strikethrough \sout
\usepackage{cancel} % strikethrough math mode \cancel
%\usepackage{enumitem} % set label in itemize
\usepackage{pifont} % for \tickNo
%\usepackage{}
%\usepackage{listings}
\usepackage[all]{xy}
%\usepackage{proof}
%\usepackage{eurosym}
%\usepackage{graphics}
\usepackage{bibentry}
%\nobibliography{short}
\bibliographystyle{plain}
%\input{prooftree}

\newtheorem{takehomemessage}[theorem]{\textbf{Take home message}}

%\usepackage{agda}
%\AgdaNoSpaceAroundCode{}

\DeclareMathSymbol{\chkmark}{\mathord}{AMSa}{"58}

% RGB colors
\definecolor{darkred}{rgb}{0.5,0,0}
\definecolor{darkgreen}{rgb}{0,0.5,0}
\definecolor{darkblue}{rgb}{0,0,0.5}
\definecolor{dirtyred}{rgb}{0.7,0.2,0.1}
\definecolor{dirtygreen}{rgb}{0.2,0.4,0.1}
\definecolor{darkdirtygreen}{rgb}{0.13,0.25,0.07}
\definecolor{dirtyblue}{rgb}{0.07,0.2,0.5}
\definecolor{darkdirtyblue}{rgb}{0.1,0.15,0.35}
\definecolor{lightblue}{rgb}{0.5,0.5,1}
\definecolor{olivegreen}{rgb}{0.5,0.5,0}
\definecolor{brown}{rgb}{0.65,0.35,0} % almost gold
\definecolor{grey}{rgb}{0.33,0.33,0.33}
\definecolor{darkbrown}{rgb}{0.35,0.15,0}
\definecolor{darkgrey}{rgb}{0.16,0.16,0.16}

\newcommand{\textred}[1]{{\color{dirtyred}\textbf{#1}}}

%\newcommand{\tickYes}{{\color{darkgreen}\checkmark}} % does not work
  %since checkmark invokes math mode
\newcommand{\tickYes}{\ensuremath{\color{darkgreen}\chkmark}}
\newcommand{\tickNo}{{\color{dirtyred}\hspace{1pt}\ding{55}}}

%\usepackage[curve,matrix,arrow]{xy}
%\usepackage{tikz} % Drawing diagrams
%\usepackage{pgflibraryshapes} %Ellipses


% MACROS:
\newcommand{\inst}{}
\input{macros}

\renewcommand{\Var}[2]{\tVar\;#1\;#2}
\renewcommand{\ru}[2]{\dfrac{\begin{array}[b]{@{}c@{}} #1 \end{array}}{\begin{array}[t]{@{}l@{}} #2 \end{array}}}

% black text in mbox
\newcommand{\mybox}[1]{\mbox{\color{black}#1}}

% meta-level logic
\renewcommand{\mfor}{\ \mybox{for}\ }
\renewcommand{\mforsome}{\ \mybox{for some}\ }
\renewcommand{\mthen}{\ \mybox{then}\ }
\renewcommand{\mif}{\ \mybox{if}\ }
\renewcommand{\miff}{\ \mybox{iff}\ }
\renewcommand{\motherwise}{\ \mybox{otherwise}}
\renewcommand{\mundefined}{\mybox{undefined}}
\renewcommand{\mnot}{\mybox{not}\ }
\renewcommand{\mand}{\ \mybox{and}\ }
\renewcommand{\mor}{\ \mybox{or}\ }
\renewcommand{\mimplies}{\ \mybox{implies}\ }
\renewcommand{\mimply}{\ \mybox{imply}\ }
\renewcommand{\mforall}{\ \mybox{for all}\ }
\renewcommand{\mexists}{\mybox{exists}\ }
\renewcommand{\mexist}{\mybox{exist}\ }
\renewcommand{\mtrue}{\mybox{true}}
\renewcommand{\mwith}{\ \mybox{with}\ }
\renewcommand{\mwhere}{\ \mybox{where}\ }
\renewcommand{\mholds}{\ \mybox{holds}\ }
\renewcommand{\munless}{\ \mybox{unless}\ }
\renewcommand{\mboth}{\ \mybox{both}\ }
\renewcommand{\msuchthat}{\ \mybox{such that}\ }
% proofs
\renewcommand{\msince}{\mybox{since}\ }
\renewcommand{\mdef}{\mybox{by def.}}
\renewcommand{\mass}{\mybox{assumption}}
\renewcommand{\mhyp}{\mybox{by hyp.}}
\renewcommand{\mlemma}[1]{\mybox{by Lemma~#1}}
\renewcommand{\mih}[1][]{\mybox{by ind.hyp.}#1}
\renewcommand{\mgoal}[1][]{\mybox{goal\ifthenelse{\equal{#1}{}}{}{~#1}}}
\renewcommand{\mby}[1]{\mybox{by #1}}
\renewcommand{\minfrule}{\mybox{by inference rule}}


% \renewcommand{\tin}{\mathsf{inn}}
% \renewcommand{\thead}{\cop{\mathsf{head}}}
% \renewcommand{\ttail}{\cop{\mathsf{tail}}}
% % start copattern color
% \newcommand{\shead}{\cop{\mathsf{head}}}
% \newcommand{\stail}{\cop{\mathsf{tail}}}
% \newcommand{\phead}{\cop{\mathsf{.head}}}
% \newcommand{\ptail}{\cop{\mathsf{.tail}}}
% \newcommand{\vecQ}{\cop{\vec Q}}
% \newcommand{\bDelta}{\boring{\Delta}}
% \newcommand{\bcovered}{\mathrel{\boring{\ccovered}}}
% \newcommand{\bA}{\boring{A}}
% \newcommand{\bC}{\boring{C}}
% \newcommand{\bder}{\mathrel{\boring{\vdash}}}
% \newcommand{\bcolon}{\mathrel{\boring{:}}}
% \newcommand{\blpar}{\boring{(}}
% \newcommand{\brpar}{\boring{)}}
% \renewcommand{\vbranches}{\boring{\mathit{branches}}}
% \renewcommand{\tout}{\cop{\mathsf{out}}}
% \renewcommand{\tforce}{\cop{\mathsf{force}}}
% \newcommand{\kw}[1]{{\bf\texttt{#1}}}
% \newcommand{\kwnewtype}{\kw{newtype}}
% \newcommand{\kwrecord}{\kw{record}}
% \newcommand{\kwwhere}{\kw{where}}
% \newcommand{\kwinstance}{\kw{instance}}
% \newcommand{\kwcoinductive}{\kw{coinductive}}
% \newcommand{\kwCoInductive}{\kw{CoInductive}}
% \newcommand{\kwCoFixpoint}{\kw{CoFixpoint}}
% \newcommand{\kwfield}{\kw{field}}
% \renewcommand{\tcase}{\mathbf{case}}
% \renewcommand{\tof}{\mathbf{of}}
% \renewcommand{\caseof}[3]{\tcase\,#1\,\tof~#2 \mathrel{\boldsymbol\To} #3}
% \newcommand{\tthead}{\cop{\texttt{head}}}
% \newcommand{\tttail}{\cop{\texttt{tail}}}
\newcommand{\ONE}{\mathbf{1}}

% DOES NOT WORK:
% rule with "boring" default text
\newcommand{\setboring}{\setbeamercolor{math text}{fg=grey}\setbeamercolor{math display}{fg=grey}}
\newcommand{\bru}[2]{\setboring\dfrac{\setboring#1}{\setboring#2}}

\renewcommand*\ttdefault{txtt} % for listing package

% \newcommand{\defHaskelllistings}{%
%   \lstset{%
%     language=Haskell,%
%     basicstyle=\ttfamily\small\color{darkdirtyblue},% \ttfamily
%     keywordstyle=\ttfamily\bfseries,% \underbar
%     identifierstyle=,%
%     commentstyle=\itshape,%
%     columns=flexible,%spaceflexible,% fixed,% flexible,%
%     showstringspaces=false,%
% %    xleftmargin=\codeindent,% defined below
%     breaklines=true,%
%     deletekeywords={succ,zero,head,tail,zipWith,Either,List},%
%     morekeywords={Set,Size,fun,cofun,pattern},% ,left,right,nil,cons
%     literate={\\}{{$\lambda$}}1 {->}{{$\rightarrow$~}}2
%              {<=}{{$\leq$~}}2 {<}{{$<$~}}1
% %     literate={map}{map~}4
% %       {even}{even~}5
% %       {odd}{odd~}4
%      }%
% }
%\defHaskelllistings

\title[Typed Lambda Definability]{%
On Typed Lambda Definability \\ and Normalization by Evaluation}

\author[Abel]{
  Andreas Abel\inst{1}
}
% \author{Andreas Abel\inst{1}
%   \and Brigitte Pientka\inst{2}
%   \and David Thibodeau\inst{2}
%   \and Anton Setzer\inst{3}
% }
%{F.~Author\inst{1} \and S.~Another\inst{2}}
% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.

\institute[] %Chalmers/GU/ENS Cachan] % (optional, but mostly needed)
{
  \inst{1}
  Department of Computer Science and Engineering\\
  Chalmers and Gothenburg University, Sweden \\[1ex]
}
%  \inst{1}%
%  Department of Computer Science\\
%  University of Somewhere
%  \and
%  \inst{2}%
%  Department of Theoretical Philosophy\\
%  University of Elsewhere}
%% - Use the \inst command only if there are several affiliations.
%% - Keep it simple, no one is interested in your street address.

\date[IFIP 1.3 2018] % (optional, should be abbreviation of conference name)
{ IFIP 1.3 Meeting 2018\\
  Royal Holloway University, London, UK \\
  6 July 2018
}
% - Either use conference name or its abbreviation.
% - Not really informative to the audience, more for people (including
%   yourself) who are reading the slides online

%\subject{Software Verification}
% This is only inserted into the PDF information catalog. Can be left
% out.



% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:

%\AtBeginSubsection[]
%\AtBeginSection[]
%{
%  \begin{frame}<beamer>
%    \frametitle{Outline}
%    \tableofcontents[currentsection,currentsubsection]
%  \end{frame}
%}


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command:

%\beamerdefaultoverlayspecification{<+->}

\makeatletter
\def\MLine#1{\par\vspace{1ex}\hspace*{-\@totalleftmargin}\parbox{\textwidth}{\[#1\]}}
\makeatother
%\newenvironment{display}{\par\vspace{1ex}\hspace*{-\@totalleftmargin}\parbox{\textwidth}{\[}{\]}}


%\newcommand{\List}{\mathsf{List}}
\renewcommand{\Set}{\mathsf{Set}}
\newcommand{\Tree}{\mathsf{Tree}}
%\newcommand{\Prop}{\mathsf{Prop}}
%\newcommand{\Type}{\mathsf{Type}}
%\newcommand{\Size}{\mathsf{Size}}
%\newcommand{\tfix}{\mathsf{fix}}
%\newcommand{\Int}{\mathsf{Int}}
%\newcommand{\tnil}{\mathsf{nil}}
%\newcommand{\tcons}{\mathsf{cons}}
%\newcommand{\vas}{\mathit{as}}
%\newcommand{\ttuple}[1]{(#1)}

%\newcommand{\oford}{\of\tord} \newcommand{\oftype}{\of\ttype}
\newcommand{\oford}{}         \newcommand{\oftype}{}
\newenvironment{prg}{\begin{quotation}\begin{tabbing}}{\end{tabbing}\end{quotation}}

% COLORS
\newcommand{\cHead}{\color{darkblue}}
\newcommand{\cSub}{\color{brown}}
\newcommand{\cWhite}{\color{white}}
\newcommand{\cGray}{\color{gray}}
\newcommand{\cGreen}{\color{olivegreen}}
\newcommand{\cBrown}{\color{brown}}
\newcommand{\cBlack}{\color{black}}
\newcommand{\black}[1]{{\cBlack#1}}

\newcommand{\cAnn}{\color{red!80!black}}%purple darkblue
\newcommand{\cAside}{\color{gray}}
\newcommand{\cEnum}{\color{darkgreen}}
\newcommand{\cEm}{\cAnn} %\color{red}}
\newcommand{\cCo}{\cAnn} %\color{red}} % copattern color
\newcommand{\cop}[1]{{\cCo#1}}
\newcommand{\cApp}{\color{violet}}
\newcommand{\capp}[1]{{\cApp#1}}
\newcommand{\cFocus}{\color{darkgreen}}
\newcommand{\focus}[1]{{\cFocus#1}}
\newcommand{\cMath}{\usebeamercolor[fg]{math text}}
\newcommand{\cIdent}{\usebeamercolor[fg]{math text}}
\newcommand{\ident}[1]{{\cIdent#1}}
\newcommand{\cExp}{\cIdent}
\newcommand{\cBoring}{\color{grey}}
\newcommand{\boring}[1]{{\cBoring#1}}

%\newcommand{\ann}[1]{^{\cAnn #1}}
\newcommand{\unn}[1]{_{\cAnn #1}}
\newcommand{\annW}[1]{^{\hphantom{#1}}}
%\newcommand{\Ann}[1]{{\cAnn #1}}
\newcommand{\AnnW}[1]{\hphantom{#1}}
\newcommand{\ttAnn}[1]{\{{\cAnn #1}\}}
% ordinal annotation
\newcommand{\cOrd}{\cAnn}
\newcommand{\onn}[1]{^{\cOrd #1}}
\newcommand{\Onn}[1]{{\cOrd #1}}
\newcommand{\oforall}[1]{\forall\Onn{#1}.~}
\newcommand{\oexists}[1]{\exists\Onn{#1}.~}
\newcommand{\oapp}[1]{\,\Onn{#1}}
\renewcommand{\emph}[1]{{\cAnn#1}}
\newcommand{\OSize}{\Onn{Size}}
\newcommand{\oi}{\Onn{i}}
\newcommand{\odi}{\Onn{\$i}}
\newcommand{\oddi}{\Onn{\$\$i}}
\newcommand{\oj}{\Onn{j}}
\newcommand{\ohash}{\Onn{\#}}

% \newcommand{\kw}[1]{{\bf#1}}
\newcommand{\kwdata}{\kw{data}}
\newcommand{\kwcodata}{\kw{codata}}
\newcommand{\kwsized}{\kw{sized}}
\newcommand{\kwfun}{\kw{fun}}
\newcommand{\kwcofun}{\kw{cofun}}
\newcommand{\kwlet}{\kw{let}}
\newcommand{\kwfields}{\kw{fields}}
%\newcommand{\kw}{\kw{}}
%\newcommand{\kw}{\kw{}}
%\newcommand{\kw}{\kw{}}
\newcommand{\tinl}{\mathsf{inl}}
\newcommand{\tinr}{\mathsf{inr}}

\renewcommand{\rulename}[1]{#1}

% types
\newcommand{\cType}{\color{orange!60!black}}


% irrelevance
\newcommand{\irr}{\mathord{\bullet}}
\newcommand{\shirr}{\mathord{{\bullet}{\bullet}}}
\renewcommand{\erhyp}[3][\irr]{#1#2 \of #3}
\newcommand{\shirrhyp}{\erhyp[\shirr]}
\renewcommand{\erfunT}[4][\irr]{(\erhyp[#1]{#2}{#3}) \to #4}
\newcommand{\serfunT}[4][\irr]{(#1#2 : #3) \to #4}
\renewcommand{\resurrect}[1]{\irr^{-1}(#1)}


\newcommand{\mlsays}[1]{}
% {\begin{frame}%[fragile=singleslide]
%   %\frametitle{Himself}
%   \begin{minipage}[c]{0.5\linewidth}
%    \includegraphics[height=0.9\textheight]{martin-loef-bw.png}
%   \end{minipage}% NO SPACE HERE!
%   \begin{minipage}[c]{0.5\linewidth}
%    \begin{center}
%      \bla \\[8ex]
%      \Huge #1
%    \end{center}
%   \end{minipage}
% \end{frame}
% }

\newcommand{\JOKE}[1]{} % No jokes.
\renewcommand{\emph}[1]{\textit{\cType#1}}

\newcommand{\ope}{\twoheadrightarrow}

\newcommand{\tcompare}{\mathsf{compare}}
\newcommand{\tensor}{\otimes}
\newcommand{\lolli}{\multimap}
\newcommand{\bang}{\mathord{!}}
\newcommand{\quest}{\mathord{?}}
\newcommand{\WW}{\mathbb{W}}
\newcommand{\LLL}{\List\,K \lolli \List\,K}
\newcommand{\vks}{\mathit{ks}}
\newcommand{\munit}{\mathbbm{1}}  % monoidal unit
\newcommand{\aff}{{\{0,1\}}}
\newcommand{\onetwo}{{\{1,2\}}}

\DeclareMathOperator*{\amp}{\&}
\DeclareMathOperator*{\bigamp}{\scalerel*{\&}{\sum}}
\usepackage{scalerel}

\begin{document}

\maketitle
%\begin{frame}
%  \titlepage
%\end{frame}

%\begin{frame}
%  \frametitle{Outline}
%  \tableofcontents
%  % You might wish to add the option [pausesections]
%\end{frame}

% Background: Dependent Types
%
% Typing judgement
% Conversion rule
% Definitional equality judgement
% - Equal terms are not distinguished
% - Fragment of extensional equality
% - The stronger the better
% - eta for unit type
%
% Example: monus
%
% Sized types and problem with proof
%
% Curry-style would solve it
% Internal: fully reconstructed: Church-Style
% Churry-style




\section{Introduction}


\begin{frame}%[fragile=singleslide]
  \frametitle{Strong Typing}
  \vspace{-3ex}
  \begin{itemize}
  \item Typing allows correct instruction selection (compilation).
  \item Typing prevents basic runtime errors.
    \begin{quote}
      Well-typed programs don't go wrong. \\
  (Robin Milner, 1978)
    \end{quote}
  \item But there is more...
  \end{itemize}
\end{frame}


\begin{frame}%[fragile=singleslide]
  \frametitle{Free Theorems from Typing}
  \vspace{-3ex}
  \begin{itemize}
  \item Reynolds 1974, Wadler 1989: Theorems for free! \\
    Polymorphic functions preserve all relations.
  \item Free theorems from linearity: % \\
    \begin{theorem}
     Every function $\List\,A \lolli \List\,A$ is a permutation. \\
     (For an abstract type $A$.)
    \end{theorem}
  \item Free theorems proven by logical relations.
  \item What about free theorems from simple typing? % \\
    \begin{theorem}
     In STLC with the only constants $\ttrue, \tfalse : \Bool$,
     boolean negation is not definable.
    \end{theorem}
  \end{itemize}
\end{frame}

\begin{frame}%[fragile=singleslide]
  \frametitle{STLC-Definability}
  %\vspace{-3ex}
  \begin{itemize}
  \item \emph{Given a function $f$ of some type, is it definable in STLC?} \\
   (Replace simply-typed lambda calculus (STLC) by your favorite
    type theory.)
  \item Extended question: Can we decide whether $f$ is STLC-definable?
  \item Trivial answer to original question:
\[
  f \mbox{ STLC-definable} \iff \exists t.\ \denty t = f
\]
\vspace{-2ex}
  \item Modified question: Can we characterize the STLC-definable
    functions without referencing STLC-syntax?
  \end{itemize}
\end{frame}


\begin{frame}%[allowframebreaks]%[fragile=singleslide]
  \frametitle{A Universe of Types}
  \vspace{-3ex}
  \begin{itemize}
  \item To talk about typed functions, we need a language of types.
\[
\begin{array}{lllrll}
  \iota & : & \mybox{\emph{$\Base$}} & & &  \mybox{base type} \\
  S,T,U & : & \Ty & ::= & \iota \mid U \To T & \mybox{simple type hierarchy} \\
\end{array}
\]
  \vspace{-2ex}
  \item Interpretation $\denty\_ : \Ty \to \Set$.
\[
\begin{array}{llll}
  \denty{\iota}   & = & \mybox{\emph{parameter}} \\
  \denty{U \To T} & = & \denty U \to \denty T
    & \mybox{full (meta-theoretic) function space}
\end{array}
\]
  \vspace{-2ex}
  % \item Our type language is parametrized by $\Base$ types and their
  %   interpretation.
  \item Constants $c : T_c$ need to satisfy $\denty c : \denty{T_c}$.
  \end{itemize}
\end{frame}


\begin{frame}%[fragile=singleslide]
  \frametitle{Contexts}
  \vspace{-3ex}
  \begin{itemize}
  \item Types of argument lists (contexts).
\[
\begin{array}{lllrll}
  \Gamma,\Delta & : & \Cxt & ::= & \cempty & \mybox{empty context}
\\ &&& \mid & \Gamma.U & \mybox{context extension}
\end{array}
\]
  \vspace{-2ex}
  \item Interpretation $\denty\_ : \Cxt \to \Set$.
\[
\begin{array}{llll}
  \denty{\cempty} & = & 1
    & \mybox{unit set}
\\
  \denty{\Gamma.U} & = & \denty \Gamma \times \denty U
    & \mybox{cartesian product}
\end{array}
\]
  \end{itemize}
\end{frame}


\begin{frame}%[fragile=singleslide]
  \frametitle{Contexts as Worlds}
  \vspace{-3ex}
  \begin{itemize}
  \item Context thinning $\Gamma \ope \Delta$.
  % \item For the sake of consistency with (record) subtyping (and to confuse the
  %   audience) I consider longer contexts as \emph{smaller}.
\[
  \ru{
    }{\tid_\Gamma : \Gamma \ope \Gamma}
\qquad
  \ru{\tau : \Gamma \ope \Delta
    }{\weak[U] \tau : \Gamma.U \ope \Delta}
\qquad
  \ru{\tau : \Gamma \ope \Delta
    }{\lift[U] \tau : \Gamma.U \ope \Delta.U}
\]
\vspace{-2ex}
  \item Makes the \emph{category of contexts and order-preserving embeddings}.
  % aka \emph{augmented simplex category}.

  \item Interpretation $\denty\_ : (\Gamma \ope \Delta) \to
    \denty\Gamma \to \denty\Delta$ as sublist projection.
\[
\begin{array}{lllll}
  \denty{\tid_\Gamma} & = & \tid_{\denty\Gamma}
    & : & \denty\Gamma \to \denty\Gamma \\
  \denty{\weak[U] \tau} & = & \denty\tau \comp \pi_1
    & : & \denty{\Gamma.U} \to \denty\Delta \\
  \denty{\lift[U] \tau} & = & \denty\tau \times \tid_{\denty U}
    & : & \denty{\Gamma.U} \to \denty{\Delta.U} \\
\end{array}
\]
  \end{itemize}
\end{frame}

\begin{frame}%[fragile=singleslide]
  \frametitle{Kripke predicates in the world of contexts}
  \vspace{-3ex}
  \begin{itemize}
  \item Predicate $f \in \Den T \Gamma$ on
    $f : \denty\Gamma \to \denty T$ needs to satisfy
    \begin{enumerate}
    \item (Monotonicity:)  If $f \in \Den T \Gamma$ and $\tau : \Delta
      \ope \Gamma$ then $f \comp \denty\tau \in \Den T \Delta$.
    \item (Kripke function space:)  $f \in \Den{U \to T}\Gamma$ iff $f
      \stackrel\tau\cdot d \in \Den T \Delta$ for all $\tau :
      \Delta \ope \Gamma$ and $d \in \Den U \Delta$.\\
      Herein: $(f \stackrel\tau\cdot d)\,\delta =
      f\,(\denty\tau\,\delta)\,(d\,\delta)$.
    \item $\denty c \in \Den {T_c} \cempty$ for all constants $c$.
    \end{enumerate}
  \item Base case $\Den \iota \Gamma$ is parameter (must be
    monotone!).
    \begin{theorem}
      A function $f : \denty\Gamma \to \denty T$ is STLC-definable iff
      it satisfies all Kripke predicates, i.e., $f \in \Den T \Gamma$
      no matter how $\den \iota$ is chosen.
    \end{theorem}
    \begin{enumerate}
    \item[$\Rightarrow$] If $t : (\Gamma \vdash T)$ then $\denty t \in
      \Den T \Gamma$ (fundamental theorem of LR).
    \item[$\Leftarrow$] $\Sigma\, t : (\Gamma \der T).\ \denty t = f$
      is a Kripke predicate $f \in \Den T \Gamma$
      (term model).
    % \item[$\Leftarrow$] $f \in \Den T \Gamma \defiff \exists t :
    %   (\Gamma \der T).\ \denty t = f$ is a Kripke predicate.
    \end{enumerate}
  \end{itemize}
\end{frame}


\begin{frame}%[fragile=singleslide]
  \frametitle{Application: Refuting STLC-definability}
  \vspace{-3ex}
  \begin{theorem}
    Boolean negation is not definable in STLC equipped with $\ttrue,
    \tfalse : \Bool$.
  \end{theorem}
  \begin{itemize}
  \item Proof 1: Look at possible normal forms of type $\Bool \to
    \Bool$.
  \item Proof 2: Construct a Kripke countermodel.
    \begin{itemize}
    \item Let $f \in \Den \Bool \Gamma$ iff $f$ is constant
      $\ttrue/\tfalse$ or a projection from $\denty\Gamma$.
    \item This is a Kripke model for STLC with $\ttrue,
    \tfalse : \Bool$.
    \item Negation is neither constant nor a projection.
    \end{itemize}
  \item By the connection between STLC-definability and normalization,
    these two proofs are somewhat ``the same''.
  \end{itemize}
  \begin{theorem}[Peirce not inhabited]
    % There are types $A,B$ such that
    There is not closed STLC-term of type
    $((A \To B) \To A) \To A$ % is not inhabited in STLC
    for some types $A,B$.
  \end{theorem}
  Proof: Exercise!
\end{frame}


\begin{frame}%[fragile=singleslide]
  \frametitle{Syntax and Interpretation of STLC}
  \vspace{-3ex}
  \begin{itemize}
  \item Variables: index  $x : \Var \Gamma T$ into the context.
\[
  \ru{}{\ind 0 : \Var {\Gamma.T} T}
\qquad
  \ru{\ind i : \Var \Gamma T
    }{\ind{i+1} : \Var {\Gamma.U} T}
\]
  \vspace{-2ex}
  \item Interpretation $\denty\_ : \Var \Gamma T \to \denty \Gamma \to \denty T$
as projections.
\[
\begin{array}{rlll}
  \denty {\ind 0}    & = & \pi_2 \\
  \denty {\ind{i+1}} & = & \denty {\ind i} \comp \pi_1 \\
\end{array}
\]
  \vspace{-2ex}
  \item Terms $t : \Gamma \der T$.
\[
  \ru{x : \Var \Gamma T
    }{x : \Gamma \der T}
\qquad
  \ru{t : \Gamma.U \der T
    }{\lambda t : \Gamma \der U \To T}
\qquad
  \ru{t : \Gamma \der U \To T \qquad
      u : \Gamma \der U
    }{t\,u : \Gamma \der T}
\]
  \item Interpretation $\denty\_ : (\Gamma \der T) \to \denty \Gamma \to \denty T$.
\[
\begin{array}{rll@{\qquad\qquad}l@{~}l@{~}l}
  \denty {\lambda t} & = & \curry \denty t
    & \curry f\;(\gamma,d) & = & f\;\gamma\;d\\
  \denty {t\,u}      & = & \tS\; \denty t\; \denty u
    & \tS\;f\;g\;\gamma & = & f\;\gamma\;(g\;\gamma) \\
\end{array}
\]
  \vspace{-2ex}
  \end{itemize}
\end{frame}


\begin{frame}%[fragile=singleslide]
  \frametitle{Fundamental theorem}
  \vspace{-3ex}
  \begin{itemize}
  \item Extension to environments: $\rho \in \Den \Gamma \Delta$ for
    $\rho : \denty\Delta \to \denty\Gamma$.
\[
\begin{array}{lll}
  \rho \in \Den \cempty \Delta & \iff & \mtrue \\
  \rho \in \Den {\Gamma.U} \Delta & \iff &
    \pi_1 \comp \rho \in \Den \Gamma \Delta \mand
    \pi_2 \comp \rho \in \Den U \Delta
\end{array}
\]
  Monotonicity: If $\rho \in \Den \Gamma \Delta$ and $\tau : \Delta'
  \ope \Delta$ then $\rho \comp \denty \tau \in \Den \Gamma{\Delta'}$.
\begin{theorem}[Fundamental theorem of logical relations]
  If $t : (\Gamma \der T)$ and $\rho \in \Den \Gamma \Delta$ then
  $\denty t \comp \rho \in \Den T \Delta$.
\end{theorem}
  \item Prove this first for $x : \Var \Gamma T$ (easy).
  \item Then prove by induction on $t : \Gamma \der T$.
  \item Case $\lambda t : \Gamma \der U \To T$:
    Show $\tcurry \denty t \comp \rho \in \Den{U \To T} \Delta$. \\
    (Needs monotonicity!)
  \item Case $t\,u : \Gamma \der T$:
    Show $(\tS\;\denty t \; \denty u) \comp \rho \in \Den T \Delta$.
  \end{itemize}
\end{frame}


\begin{frame}%[fragile=singleslide]
  \frametitle{Term model}
  \vspace{-3ex}
  \begin{itemize}
  \item Define $f \in \Den \iota \Gamma$ as $\Sigma t : (\Gamma \der
    \iota).\ \denty t = f$.
    \begin{theorem}[Reflect/reify]
      \begin{enumerate}
      \item If $t : \Gamma \der T$ then $\denty t \in \Den T \Gamma$ (reflect).
      \item If $f \in \Den T \Gamma$ then $\denty t = f$ for some $t :
        \Gamma \der T$ (reify).
      \end{enumerate}
    \end{theorem}
  \item Prove simulateneously by induction on $T$.
  \item Discovery: does not introduce $\beta$-redexes!
  \end{itemize}
\end{frame}


\begin{frame}%[fragile=singleslide]
  \frametitle{Normal forms}
  \vspace{-3ex}
  \begin{itemize}
  \item Define simultaneously $t : \Ne \Gamma T$ (neutral)
  and $t : \Nf \Gamma T$ (normal).
\[
  \ru{x : \Var \Gamma T
    }{x : \Ne \Gamma T}
\qquad
  \ru{t : \Ne \Gamma (U \To T) \qquad u : \Nf \Gamma U
    }{t\,u : \Ne \Gamma T}
\]
\[
  \ru{t : \Ne \Gamma T
    }{t : \Nf \Gamma T}
\qquad
  \ru{t : \Nf {\Gamma.U} T
    }{\lambda t : \Nf \Gamma (U \To T)}
\]
  \item Define $f \in \Den \iota \Gamma$ as $\Sigma (t : \Ne \Gamma
    \iota).\ \denty t = f$.
    \begin{theorem}[Reflect/reify]
      \begin{enumerate}
      \item If $t : \Ne \Gamma T$ then $\denty t \in \Den T \Gamma$ (reflect).
      \item If $f \in \Den T \Gamma$ then $\denty t = f$ for some $t :
        \Nf \Gamma T$ (reify).
      \end{enumerate}
    \end{theorem}
  \end{itemize}
\end{frame}


\begin{frame}%[fragile=singleslide]
  \frametitle{Normalization by Evaluation}
  \vspace{-3ex}
  \begin{itemize}
  \item Show $id_{\denty \Gamma} \in \Den \Gamma \Gamma$ (reflection!).
  \item Assume $t : \Gamma \der T$.
  \item By the fundamental theorem, $\denty t \comp id : \Den T
    \Gamma$.
  \item By reification, $\denty t = \denty v$ for some $v : \Nf \Gamma T$.
  \end{itemize}
\end{frame}

\begin{frame}[fragile=singleslide]
  \frametitle{Conclusions}
  \vspace{-3ex}
  \begin{itemize}
  \item Proof-relevant version of completeness proof of IPL.
  \item Implemented in Agda with a tiny bit of \verb|--rewriting|.\\
  \url{https://github.com/andreasabel/lambda-definability/tree/master/src-stlc}
  \item Extension to sum types: % in progress:
    \begin{itemize}
    \item Use Beth models to incorporate case trees.
    \item Need lots of \verb|--rewriting|.
    \end{itemize}
  \item Aspired future work: Extension to dependent types.
% : still figuring out stuff. \\
%     Related to McBride's \emph{Outrageous But Meaningful Coincidences}?!
  \end{itemize}
\end{frame}

\begin{frame}%[fragile=singleslide]
  \frametitle{Related Work}
  %\vspace{-3ex}
  \begin{itemize}
  \item A. (habil. 2013): ``Type-assignment NbE'' for dependent and
    polymorphic types.
  \item What I presented here are classic results:
    \begin{itemize}
  \item Friedman / Plotkin (1970s/80s): Logical relations.
  \item Catarina Coquand (1993): NbE for STLC$\sigma$ using Kripke model
  \item Jung, Tiuryn (TLCA 1993): More or less this formulation.
    \end{itemize}
  \item Fiore, Simpson (TLCA 1999); Altenkirch, Dybjer, Hofmann, Scott
    (LICS 2001): Extension to disjoint sum types.
  \item Altenkirch Kaposi 2016: Extension to $\Pi$-types.
  \end{itemize}
\end{frame}


% \begin{frame}%[fragile=singleslide]
%   \frametitle{Future work}
%   %\vspace{-3ex}
%   \begin{itemize}
%   \item
%   \end{itemize}
% \end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% END DOC %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \bibliography{short}

\end{document}




\begin{frame}%[fragile=singleslide]
  \frametitle{}
  \vspace{-3ex}
  \begin{itemize}
  \item
  \end{itemize}
\end{frame}


\begin{frame}%[fragile=singleslide]
  \frametitle{}
  \vspace{-3ex}
  \begin{itemize}
  \item
  \end{itemize}
\end{frame}


\begin{frame}%[fragile=singleslide]
  \frametitle{}
  \vspace{-3ex}
  \begin{itemize}
  \item
  \end{itemize}
\end{frame}


\begin{frame}%[fragile=singleslide]
  \frametitle{}
  \vspace{-3ex}
  \begin{itemize}
  \item
  \end{itemize}
\end{frame}


\begin{frame}%[fragile=singleslide]
  \frametitle{}
  \vspace{-3ex}
  \begin{itemize}
  \item
  \end{itemize}
\end{frame}


\begin{frame}%[fragile=singleslide]
  \frametitle{}
  \vspace{-3ex}
  \begin{itemize}
  \item
  \end{itemize}
\end{frame}


\begin{frame}%[fragile=singleslide]
  \frametitle{}
  \vspace{-3ex}
  \begin{itemize}
  \item
  \end{itemize}
\end{frame}

\end{document}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
