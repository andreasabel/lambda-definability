<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>NotNotDefinable</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">-- Simply-typed lambda definability and normalization by evaluation</a>
<a id="69" class="Comment">-- formalized in Agda</a>
<a id="91" class="Comment">--</a>
<a id="94" class="Comment">-- Author: Andreas Abel, May/June 2018</a>

<a id="134" class="Comment">-- 4a. Using Kripke predicates to refute STLC-definability of boolean negation.</a>

<a id="215" class="Symbol">{-#</a> <a id="219" class="Keyword">OPTIONS</a> <a id="227" class="Pragma">--postfix-projections</a> <a id="249" class="Symbol">#-}</a>
<a id="253" class="Symbol">{-#</a> <a id="257" class="Keyword">OPTIONS</a> <a id="265" class="Pragma">--rewriting</a> <a id="277" class="Symbol">#-}</a>

<a id="282" class="Keyword">open</a> <a id="287" class="Keyword">import</a> <a id="294" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>
<a id="309" class="Keyword">open</a> <a id="314" class="Keyword">import</a> <a id="321" href="Library.html" class="Module">Library</a>

<a id="330" class="Keyword">import</a> <a id="337" href="SimpleTypes.html" class="Module">SimpleTypes</a>
<a id="349" class="Keyword">import</a> <a id="356" href="STLCDefinable.html" class="Module">STLCDefinable</a>

<a id="371" class="Keyword">module</a> <a id="378" href="NotNotDefinable.html" class="Module">NotNotDefinable</a> <a id="394" class="Keyword">where</a>

<a id="401" class="Comment">-- We consider STLC with a base type &quot;bool&quot; that is inhabited by</a>
<a id="466" class="Comment">-- two constants &quot;true&quot; and &quot;false&quot;.</a>

<a id="504" class="Keyword">data</a> <a id="Base"></a><a id="509" href="NotNotDefinable.html#509" class="Datatype">Base</a> <a id="514" class="Symbol">:</a> <a id="516" class="PrimitiveType">Set</a> <a id="520" class="Keyword">where</a>
  <a id="Base.bool"></a><a id="528" href="NotNotDefinable.html#528" class="InductiveConstructor">bool</a> <a id="533" class="Symbol">:</a> <a id="535" href="NotNotDefinable.html#509" class="Datatype">Base</a>

<a id="B⦅_⦆"></a><a id="541" href="NotNotDefinable.html#541" class="Function Operator">B⦅_⦆</a> <a id="546" class="Symbol">:</a> <a id="548" href="NotNotDefinable.html#509" class="Datatype">Base</a> <a id="553" class="Symbol">→</a> <a id="555" class="PrimitiveType">Set</a>
<a id="559" href="NotNotDefinable.html#541" class="Function Operator">B⦅</a> <a id="562" href="NotNotDefinable.html#528" class="InductiveConstructor">bool</a> <a id="567" href="NotNotDefinable.html#541" class="Function Operator">⦆</a> <a id="569" class="Symbol">=</a> <a id="571" href="Agda.Builtin.Bool.html#135" class="Datatype">Bool</a>

<a id="577" class="Keyword">open</a> <a id="582" href="SimpleTypes.html" class="Module">SimpleTypes</a> <a id="594" href="NotNotDefinable.html#509" class="Datatype">Base</a> <a id="599" href="NotNotDefinable.html#541" class="Function Operator">B⦅_⦆</a>

<a id="605" class="Keyword">data</a> <a id="Const"></a><a id="610" href="NotNotDefinable.html#610" class="Datatype">Const</a> <a id="616" class="Symbol">:</a> <a id="618" class="PrimitiveType">Set</a> <a id="622" class="Keyword">where</a>
  <a id="Const.true"></a><a id="630" href="NotNotDefinable.html#630" class="InductiveConstructor">true</a>  <a id="636" class="Symbol">:</a> <a id="638" href="NotNotDefinable.html#610" class="Datatype">Const</a>
  <a id="Const.false"></a><a id="646" href="NotNotDefinable.html#646" class="InductiveConstructor">false</a> <a id="652" class="Symbol">:</a> <a id="654" href="NotNotDefinable.html#610" class="Datatype">Const</a>

<a id="ty"></a><a id="661" href="NotNotDefinable.html#661" class="Function">ty</a> <a id="664" class="Symbol">:</a> <a id="666" href="NotNotDefinable.html#610" class="Datatype">Const</a> <a id="672" class="Symbol">→</a> <a id="674" href="SimpleTypes.html#553" class="Datatype">Ty</a>
<a id="677" href="NotNotDefinable.html#661" class="Function">ty</a> <a id="680" href="NotNotDefinable.html#630" class="InductiveConstructor">true</a>  <a id="686" class="Symbol">=</a> <a id="688" href="SimpleTypes.html#570" class="InductiveConstructor">base</a> <a id="693" href="NotNotDefinable.html#528" class="InductiveConstructor">bool</a>
<a id="698" href="NotNotDefinable.html#661" class="Function">ty</a> <a id="701" href="NotNotDefinable.html#646" class="InductiveConstructor">false</a> <a id="707" class="Symbol">=</a> <a id="709" href="SimpleTypes.html#570" class="InductiveConstructor">base</a> <a id="714" href="NotNotDefinable.html#528" class="InductiveConstructor">bool</a>

<a id="c⦅_⦆"></a><a id="720" href="NotNotDefinable.html#720" class="Function Operator">c⦅_⦆</a> <a id="725" class="Symbol">:</a> <a id="727" class="Symbol">(</a><a id="728" href="NotNotDefinable.html#728" class="Bound">c</a> <a id="730" class="Symbol">:</a> <a id="732" href="NotNotDefinable.html#610" class="Datatype">Const</a><a id="737" class="Symbol">)</a> <a id="739" class="Symbol">→</a> <a id="741" href="SimpleTypes.html#1335" class="Function Operator">T⦅</a> <a id="744" href="NotNotDefinable.html#661" class="Function">ty</a> <a id="747" href="NotNotDefinable.html#728" class="Bound">c</a> <a id="749" href="SimpleTypes.html#1335" class="Function Operator">⦆</a>
<a id="751" href="NotNotDefinable.html#720" class="Function Operator">c⦅</a> <a id="754" href="NotNotDefinable.html#630" class="InductiveConstructor">true</a> <a id="759" href="NotNotDefinable.html#720" class="Function Operator">⦆</a> <a id="761" class="Symbol">=</a> <a id="763" href="Agda.Builtin.Bool.html#160" class="InductiveConstructor">true</a>
<a id="768" href="NotNotDefinable.html#720" class="Function Operator">c⦅</a> <a id="771" href="NotNotDefinable.html#646" class="InductiveConstructor">false</a> <a id="777" href="NotNotDefinable.html#720" class="Function Operator">⦆</a> <a id="779" class="Symbol">=</a> <a id="781" href="Agda.Builtin.Bool.html#154" class="InductiveConstructor">false</a>

<a id="788" class="Comment">-- We now prove that negation is not STLC definable</a>
<a id="840" class="Comment">-- by constructing a countermodel.</a>

<a id="876" class="Keyword">open</a> <a id="881" href="STLCDefinable.html" class="Module">STLCDefinable</a> <a id="895" href="NotNotDefinable.html#509" class="Datatype">Base</a> <a id="900" href="NotNotDefinable.html#541" class="Function Operator">B⦅_⦆</a> <a id="905" href="NotNotDefinable.html#610" class="Datatype">Const</a> <a id="911" href="NotNotDefinable.html#661" class="Function">ty</a> <a id="914" href="NotNotDefinable.html#720" class="Function Operator">c⦅_⦆</a>

<a id="920" class="Comment">-- We define the predicate to be &quot;constant or a projection&quot;.</a>
<a id="981" class="Comment">--</a>
<a id="984" class="Comment">-- To be a projection is to be the image of a variable under evaluation.</a>
<a id="1057" class="Comment">-- This seems to be the most economic definition.</a>
<a id="1107" class="Comment">-- A direct definition by induction on the context would look very similar.</a>

<a id="1184" class="Keyword">data</a> <a id="IsConstantOrProjection"></a><a id="1189" href="NotNotDefinable.html#1189" class="Datatype">IsConstantOrProjection</a> <a id="1212" href="NotNotDefinable.html#1212" class="Bound">Γ</a> <a id="1214" href="NotNotDefinable.html#1214" class="Bound">T</a> <a id="1216" class="Symbol">(</a><a id="1217" href="NotNotDefinable.html#1217" class="Bound">f</a> <a id="1219" class="Symbol">:</a> <a id="1221" href="SimpleTypes.html#1490" class="Function">Fun</a> <a id="1225" href="NotNotDefinable.html#1212" class="Bound">Γ</a> <a id="1227" href="NotNotDefinable.html#1214" class="Bound">T</a><a id="1228" class="Symbol">)</a> <a id="1230" class="Symbol">:</a> <a id="1232" class="PrimitiveType">Set</a> <a id="1236" class="Keyword">where</a>
  <a id="IsConstantOrProjection.isConstant"></a><a id="1244" href="NotNotDefinable.html#1244" class="InductiveConstructor">isConstant</a>   <a id="1257" class="Symbol">:</a> <a id="1259" class="Symbol">(</a><a id="1260" href="NotNotDefinable.html#1260" class="Bound">eq</a> <a id="1263" class="Symbol">:</a> <a id="1265" class="Symbol">∀</a> <a id="1267" href="NotNotDefinable.html#1267" class="Bound">γ</a> <a id="1269" href="NotNotDefinable.html#1269" class="Bound">γ&#39;</a> <a id="1272" class="Symbol">→</a> <a id="1274" href="NotNotDefinable.html#1217" class="Bound">f</a> <a id="1276" href="NotNotDefinable.html#1267" class="Bound">γ</a> <a id="1278" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1280" href="NotNotDefinable.html#1217" class="Bound">f</a> <a id="1282" href="NotNotDefinable.html#1269" class="Bound">γ&#39;</a><a id="1284" class="Symbol">)</a>      <a id="1291" class="Symbol">→</a> <a id="1293" href="NotNotDefinable.html#1189" class="Datatype">IsConstantOrProjection</a> <a id="1316" href="NotNotDefinable.html#1212" class="Bound">Γ</a> <a id="1318" href="NotNotDefinable.html#1214" class="Bound">T</a> <a id="1320" href="NotNotDefinable.html#1217" class="Bound">f</a>
  <a id="IsConstantOrProjection.isProjection"></a><a id="1324" href="NotNotDefinable.html#1324" class="InductiveConstructor">isProjection</a> <a id="1337" class="Symbol">:</a> <a id="1339" class="Symbol">(</a><a id="1340" href="NotNotDefinable.html#1340" class="Bound">x</a> <a id="1342" class="Symbol">:</a> <a id="1344" href="STLCDefinable.html#2356" class="Datatype">Var</a> <a id="1348" href="NotNotDefinable.html#1214" class="Bound">T</a> <a id="1350" href="NotNotDefinable.html#1212" class="Bound">Γ</a><a id="1351" class="Symbol">)</a> <a id="1353" class="Symbol">(</a><a id="1354" href="NotNotDefinable.html#1354" class="Bound">eq</a> <a id="1357" class="Symbol">:</a> <a id="1359" href="NotNotDefinable.html#1217" class="Bound">f</a> <a id="1361" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="1363" href="STLCDefinable.html#3466" class="Function Operator">V⦅</a> <a id="1366" href="NotNotDefinable.html#1340" class="Bound">x</a> <a id="1368" href="STLCDefinable.html#3466" class="Function Operator">⦆</a><a id="1369" class="Symbol">)</a> <a id="1371" class="Symbol">→</a> <a id="1373" href="NotNotDefinable.html#1189" class="Datatype">IsConstantOrProjection</a> <a id="1396" href="NotNotDefinable.html#1212" class="Bound">Γ</a> <a id="1398" href="NotNotDefinable.html#1214" class="Bound">T</a> <a id="1400" href="NotNotDefinable.html#1217" class="Bound">f</a>

<a id="1403" class="Comment">-- Negation is neither constant nor a projection from the singleton context (x:bool).</a>

<a id="not′"></a><a id="1490" href="NotNotDefinable.html#1490" class="Function">not′</a> <a id="1495" class="Symbol">:</a> <a id="1497" href="SimpleTypes.html#1490" class="Function">Fun</a> <a id="1501" class="Symbol">(</a><a id="1502" href="SimpleTypes.html#694" class="InductiveConstructor">ε</a> <a id="1504" href="SimpleTypes.html#704" class="InductiveConstructor Operator">▷</a> <a id="1506" href="SimpleTypes.html#570" class="InductiveConstructor">base</a> <a id="1511" href="NotNotDefinable.html#528" class="InductiveConstructor">bool</a><a id="1515" class="Symbol">)</a> <a id="1517" class="Symbol">(</a><a id="1518" href="SimpleTypes.html#570" class="InductiveConstructor">base</a> <a id="1523" href="NotNotDefinable.html#528" class="InductiveConstructor">bool</a><a id="1527" class="Symbol">)</a>
<a id="1529" href="NotNotDefinable.html#1490" class="Function">not′</a> <a id="1534" class="Symbol">=</a> <a id="1536" href="Data.Bool.Base.html#961" class="Function">not</a> <a id="1540" href="Function.html#3311" class="Function Operator">∘′</a> <a id="1543" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a>

<a id="notNotConstantOrProjection"></a><a id="1550" href="NotNotDefinable.html#1550" class="Function">notNotConstantOrProjection</a> <a id="1577" class="Symbol">:</a> <a id="1579" href="NotNotDefinable.html#1189" class="Datatype">IsConstantOrProjection</a> <a id="1602" class="Symbol">(</a><a id="1603" href="SimpleTypes.html#694" class="InductiveConstructor">ε</a> <a id="1605" href="SimpleTypes.html#704" class="InductiveConstructor Operator">▷</a> <a id="1607" href="SimpleTypes.html#570" class="InductiveConstructor">base</a> <a id="1612" href="NotNotDefinable.html#528" class="InductiveConstructor">bool</a><a id="1616" class="Symbol">)</a> <a id="1618" class="Symbol">(</a><a id="1619" href="SimpleTypes.html#570" class="InductiveConstructor">base</a> <a id="1624" href="NotNotDefinable.html#528" class="InductiveConstructor">bool</a><a id="1628" class="Symbol">)</a> <a id="1630" href="NotNotDefinable.html#1490" class="Function">not′</a> <a id="1635" class="Symbol">→</a> <a id="1637" href="Data.Empty.html#279" class="Datatype">⊥</a>
<a id="1639" href="NotNotDefinable.html#1550" class="Function">notNotConstantOrProjection</a> <a id="1666" class="Symbol">(</a><a id="1667" href="NotNotDefinable.html#1244" class="InductiveConstructor">isConstant</a> <a id="1678" href="NotNotDefinable.html#1678" class="Bound">eq</a><a id="1680" class="Symbol">)</a>      <a id="1687" class="Symbol">=</a> <a id="1689" href="Function.html#3662" class="Function Operator">case</a> <a id="1694" href="NotNotDefinable.html#1678" class="Bound">eq</a> <a id="1697" class="Symbol">(_</a> <a id="1700" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1702" href="Agda.Builtin.Bool.html#160" class="InductiveConstructor">true</a><a id="1706" class="Symbol">)</a> <a id="1708" class="Symbol">(_</a> <a id="1711" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1713" href="Agda.Builtin.Bool.html#154" class="InductiveConstructor">false</a><a id="1718" class="Symbol">)</a> <a id="1720" href="Function.html#3662" class="Function Operator">of</a> <a id="1723" class="Symbol">λ()</a>
<a id="1727" href="NotNotDefinable.html#1550" class="Function">notNotConstantOrProjection</a> <a id="1754" class="Symbol">(</a><a id="1755" href="NotNotDefinable.html#1324" class="InductiveConstructor">isProjection</a> <a id="1768" href="STLCDefinable.html#2395" class="InductiveConstructor">vz</a> <a id="1771" href="NotNotDefinable.html#1771" class="Bound">eq</a><a id="1773" class="Symbol">)</a> <a id="1775" class="Symbol">=</a> <a id="1777" href="Function.html#3662" class="Function Operator">case</a> <a id="1782" href="Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="1787" class="Symbol">(λ</a> <a id="1790" href="NotNotDefinable.html#1790" class="Bound">z</a> <a id="1792" class="Symbol">→</a> <a id="1794" href="NotNotDefinable.html#1790" class="Bound">z</a> <a id="1796" class="Symbol">(_</a> <a id="1799" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="1801" href="Agda.Builtin.Bool.html#160" class="InductiveConstructor">true</a><a id="1805" class="Symbol">))</a> <a id="1808" href="NotNotDefinable.html#1771" class="Bound">eq</a> <a id="1811" href="Function.html#3662" class="Function Operator">of</a> <a id="1814" class="Symbol">λ()</a>
<a id="1818" href="NotNotDefinable.html#1550" class="Function">notNotConstantOrProjection</a> <a id="1845" class="Symbol">(</a><a id="1846" href="NotNotDefinable.html#1324" class="InductiveConstructor">isProjection</a> <a id="1859" class="Symbol">(</a><a id="1860" href="STLCDefinable.html#2423" class="InductiveConstructor">STLCDefinable.vs</a> <a id="1877" class="Symbol">())</a> <a id="1881" href="NotNotDefinable.html#1881" class="Bound">eq</a><a id="1883" class="Symbol">)</a>

<a id="1886" class="Comment">-- &quot;Being constant or a projection&quot; is a valid Kripke logical predicate at base type.</a>
<a id="1972" class="Comment">-- This amounts to show monotonicity, i.e., closure under composition with projections τ.</a>

<a id="NN-Base"></a><a id="2063" href="NotNotDefinable.html#2063" class="Function">NN-Base</a> <a id="2071" class="Symbol">:</a> <a id="2073" href="STLCDefinable.html#682" class="Record">STLC-KLP-Base</a>
<a id="2087" href="NotNotDefinable.html#2063" class="Function">NN-Base</a> <a id="2095" class="Symbol">.</a><a id="2096" href="STLCDefinable.html#721" class="Field Operator">STLCDefinable.STLC-KLP-Base.B⟦_⟧</a> <a id="2129" href="NotNotDefinable.html#528" class="InductiveConstructor">bool</a> <a id="2134" href="NotNotDefinable.html#2134" class="Bound">Γ</a> <a id="2136" href="NotNotDefinable.html#2136" class="Bound">f</a> <a id="2138" class="Symbol">=</a> <a id="2140" href="NotNotDefinable.html#1189" class="Datatype">IsConstantOrProjection</a> <a id="2163" href="NotNotDefinable.html#2134" class="Bound">Γ</a> <a id="2165" class="Symbol">_</a> <a id="2167" href="NotNotDefinable.html#2136" class="Bound">f</a>
<a id="2169" href="NotNotDefinable.html#2063" class="Function">NN-Base</a> <a id="2177" class="Symbol">.</a><a id="2178" href="STLCDefinable.html#759" class="Field">STLCDefinable.STLC-KLP-Base.monB</a> <a id="2211" href="NotNotDefinable.html#528" class="InductiveConstructor">bool</a> <a id="2216" href="NotNotDefinable.html#2216" class="Bound">τ</a> <a id="2218" class="Symbol">(</a><a id="2219" href="NotNotDefinable.html#1244" class="InductiveConstructor">isConstant</a> <a id="2230" href="NotNotDefinable.html#2230" class="Bound">eq</a><a id="2232" class="Symbol">)</a> <a id="2234" class="Symbol">=</a>
  <a id="2238" href="NotNotDefinable.html#1244" class="InductiveConstructor">isConstant</a> <a id="2249" class="Symbol">(λ</a> <a id="2252" href="NotNotDefinable.html#2252" class="Bound">γ</a> <a id="2254" href="NotNotDefinable.html#2254" class="Bound">γ&#39;</a> <a id="2257" class="Symbol">→</a> <a id="2259" href="NotNotDefinable.html#2230" class="Bound">eq</a> <a id="2262" class="Symbol">(</a><a id="2263" href="SimpleTypes.html#1696" class="Function Operator">R⦅</a> <a id="2266" href="NotNotDefinable.html#2216" class="Bound">τ</a> <a id="2268" href="SimpleTypes.html#1696" class="Function Operator">⦆</a> <a id="2270" href="NotNotDefinable.html#2252" class="Bound">γ</a><a id="2271" class="Symbol">)</a> <a id="2273" class="Symbol">(</a><a id="2274" href="SimpleTypes.html#1696" class="Function Operator">R⦅</a> <a id="2277" href="NotNotDefinable.html#2216" class="Bound">τ</a> <a id="2279" href="SimpleTypes.html#1696" class="Function Operator">⦆</a> <a id="2281" href="NotNotDefinable.html#2254" class="Bound">γ&#39;</a><a id="2283" class="Symbol">))</a>
<a id="2286" href="NotNotDefinable.html#2063" class="Function">NN-Base</a> <a id="2294" class="Symbol">.</a><a id="2295" href="STLCDefinable.html#759" class="Field">STLCDefinable.STLC-KLP-Base.monB</a> <a id="2328" href="NotNotDefinable.html#528" class="InductiveConstructor">bool</a> <a id="2333" href="NotNotDefinable.html#2333" class="Bound">τ</a> <a id="2335" class="Symbol">(</a><a id="2336" href="NotNotDefinable.html#1324" class="InductiveConstructor">isProjection</a> <a id="2349" href="NotNotDefinable.html#2349" class="Bound">x</a> <a id="2351" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="2355" class="Symbol">)</a> <a id="2357" class="Symbol">=</a>
  <a id="2361" href="NotNotDefinable.html#1324" class="InductiveConstructor">isProjection</a> <a id="2374" class="Symbol">(</a><a id="2375" href="NotNotDefinable.html#2349" class="Bound">x</a> <a id="2377" href="STLCDefinable.html#2918" class="Function Operator">w[</a> <a id="2380" href="NotNotDefinable.html#2333" class="Bound">τ</a> <a id="2382" href="STLCDefinable.html#2918" class="Function Operator">]ᵛ</a><a id="2384" class="Symbol">)</a> <a id="2386" class="Symbol">(</a><a id="2387" href="Relation.Binary.PropositionalEquality.Core.html#939" class="Function">sym</a> <a id="2391" class="Symbol">(</a><a id="2392" href="STLCDefinable.html#3892" class="Function">wk-evalv</a> <a id="2401" href="NotNotDefinable.html#2349" class="Bound">x</a> <a id="2403" href="NotNotDefinable.html#2333" class="Bound">τ</a><a id="2404" class="Symbol">))</a>

<a id="2408" class="Comment">-- The constants true/false satisfy this KLP.</a>
<a id="2454" class="Comment">-- (Because they denote constant functions.)</a>

<a id="NN"></a><a id="2500" href="NotNotDefinable.html#2500" class="Function">NN</a> <a id="2503" class="Symbol">:</a> <a id="2505" href="STLCDefinable.html#1657" class="Record">STLC-KLP</a>
<a id="2514" href="NotNotDefinable.html#2500" class="Function">NN</a> <a id="2517" class="Symbol">.</a><a id="2518" href="STLCDefinable.html#1691" class="Field">STLCDefinable.STLC-KLP.klp-base</a> <a id="2550" class="Symbol">=</a> <a id="2552" href="NotNotDefinable.html#2063" class="Function">NN-Base</a>
<a id="2560" href="NotNotDefinable.html#2500" class="Function">NN</a> <a id="2563" class="Symbol">.</a><a id="2564" href="STLCDefinable.html#1801" class="Field">STLCDefinable.STLC-KLP.satC</a> <a id="2592" href="NotNotDefinable.html#630" class="InductiveConstructor">true</a>  <a id="2598" class="Symbol">=</a> <a id="2600" href="NotNotDefinable.html#1244" class="InductiveConstructor">isConstant</a> <a id="2611" class="Symbol">(λ</a> <a id="2614" href="NotNotDefinable.html#2614" class="Bound">_</a> <a id="2616" href="NotNotDefinable.html#2616" class="Bound">_</a> <a id="2618" class="Symbol">→</a> <a id="2620" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="2624" class="Symbol">)</a>
<a id="2626" href="NotNotDefinable.html#2500" class="Function">NN</a> <a id="2629" class="Symbol">.</a><a id="2630" href="STLCDefinable.html#1801" class="Field">STLCDefinable.STLC-KLP.satC</a> <a id="2658" href="NotNotDefinable.html#646" class="InductiveConstructor">false</a> <a id="2664" class="Symbol">=</a> <a id="2666" href="NotNotDefinable.html#1244" class="InductiveConstructor">isConstant</a> <a id="2677" class="Symbol">(λ</a> <a id="2680" href="NotNotDefinable.html#2680" class="Bound">_</a> <a id="2682" href="NotNotDefinable.html#2682" class="Bound">_</a> <a id="2684" class="Symbol">→</a> <a id="2686" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="2690" class="Symbol">)</a>

<a id="2693" class="Comment">-- Since negation is not modelled by this predicate, it cannot be STLC-definable.</a>

<a id="thm"></a><a id="2776" href="NotNotDefinable.html#2776" class="Function">thm</a> <a id="2780" class="Symbol">:</a> <a id="2782" href="STLCDefinable.html#2020" class="Function">STLC-definable</a> <a id="2797" class="Symbol">(</a><a id="2798" href="SimpleTypes.html#694" class="InductiveConstructor">ε</a> <a id="2800" href="SimpleTypes.html#704" class="InductiveConstructor Operator">▷</a> <a id="2802" href="SimpleTypes.html#570" class="InductiveConstructor">base</a> <a id="2807" href="NotNotDefinable.html#528" class="InductiveConstructor">bool</a><a id="2811" class="Symbol">)</a> <a id="2813" class="Symbol">(</a><a id="2814" href="SimpleTypes.html#570" class="InductiveConstructor">base</a> <a id="2819" href="NotNotDefinable.html#528" class="InductiveConstructor">bool</a><a id="2823" class="Symbol">)</a> <a id="2825" href="NotNotDefinable.html#1490" class="Function">not′</a> <a id="2830" class="Symbol">→</a> <a id="2832" href="Data.Empty.html#279" class="Datatype">⊥</a>
<a id="2834" href="NotNotDefinable.html#2776" class="Function">thm</a> <a id="2838" href="NotNotDefinable.html#2838" class="Bound">def</a> <a id="2842" class="Symbol">=</a> <a id="2844" href="NotNotDefinable.html#1550" class="Function">notNotConstantOrProjection</a> <a id="2871" class="Symbol">(</a><a id="2872" href="NotNotDefinable.html#2838" class="Bound">def</a> <a id="2876" href="NotNotDefinable.html#2500" class="Function">NN</a><a id="2878" class="Symbol">)</a>

<a id="2881" class="Comment">-- Q.E.D.</a>
</pre></body></html>